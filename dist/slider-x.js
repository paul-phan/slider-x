/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./draggable.js":
/*!**********************!*\
  !*** ./draggable.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("void function ($) {\n  var x, y, deltaX, deltaY, offsetX, offsetY, distance, direction, velocityX, velocityY, timeStart, timeStop, timeOffset, axis, foundAxis, event, target, tapped, dragging, isTouchDevice, now, DRAG_DATA;\n  $(window).one('touchstart', function (e) {\n    isTouchDevice = true;\n  });\n  $(document).ready(function () {\n    bindEvent(document.body, 'touchstart', tap);\n    bindEvent(document.body, 'touchmove', drag);\n    bindEvent(document.body, 'touchend', release);\n    bindEvent(document.body, 'touchcancel', release);\n    bindEvent(document.body, 'mousedown', tap);\n    bindEvent(document.body, 'mousemove', drag);\n    bindEvent(document.body, 'mouseup', release);\n    bindEvent(document.body, 'blur', release);\n    $(window).on('mouseout', function (e) {\n      e.toElement || release(e);\n    });\n  });\n\n  function tap(e) {\n    if (e.target.classList.contains('jsn-es-draggable')) {\n      target = $(e.target);\n    } else {\n      var parent = findParentNode(e.target);\n\n      if (parent) {\n        target = $(parent);\n      } else {\n        return;\n      }\n    }\n\n    if (tapped) return;\n    now = timeStart = Date.now();\n    DRAG_DATA = {};\n\n    switch (e.type) {\n      case 'mousedown':\n        if (isTouchDevice) return;\n        x = e.pageX;\n        y = e.pageY;\n        e.preventDefault();\n        break;\n\n      case 'touchstart':\n        if (e.touches.length != 1) return;\n        x = e.touches[0].clientX;\n        y = e.touches[0].clientY;\n        break;\n    }\n\n    deltaX = 0;\n    deltaY = 0;\n    offsetX = 0;\n    offsetY = 0;\n    foundAxis = null;\n    distance = 0;\n    direction = 'none';\n    axis = 'none';\n    tapped = true;\n  }\n\n  function drag(e) {\n    if (!tapped) return;\n\n    switch (e.type) {\n      case 'mousemove':\n        if (isTouchDevice) return;\n        var pageX = e.pageX;\n        var pageY = e.pageY;\n        e.preventDefault();\n        break;\n\n      case 'touchmove':\n        if (e.touches.length != 1) return;\n        var pageX = e.touches[0].clientX;\n        var pageY = e.touches[0].clientY;\n        break;\n    }\n\n    now = Date.now();\n    deltaX = pageX - x;\n    deltaY = pageY - y;\n    offsetX += deltaX;\n    offsetY += deltaY;\n    x = pageX;\n    y = pageY;\n\n    if (!foundAxis) {\n      if (Math.abs(offsetX) > Math.abs(offsetY)) {\n        axis = 'x';\n      } else if (Math.abs(offsetX) < Math.abs(offsetY)) {\n        axis = 'y';\n      } else {\n        axis = 'none';\n      }\n\n      distance = Math.max(Math.abs(offsetX), Math.abs(offsetY));\n      if (distance > 50) foundAxis = true;\n    }\n\n    Math.abs(deltaX) >= Math.abs(deltaY) ? direction = deltaX > 0 ? 'right' : deltaX < 0 ? 'left' : 'none' : direction = deltaY > 0 ? 'down' : deltaY < 0 ? 'up' : 'none';\n\n    if (!dragging) {\n      dragging = true;\n      target.trigger(createEvent('es_dragstart', e), getData());\n      $('body').add(target).addClass('jsn-es-draggable-dragging');\n    }\n\n    if (dragging) {\n      timeStop = Date.now();\n      calculateVelocity();\n      timeStart = Date.now();\n      target.trigger(createEvent('es_dragmove', e), getData());\n    }\n  }\n\n  function release(e) {\n    if (!tapped) return;\n\n    switch (e.type) {\n      case 'touchend':\n      case 'touchcancel':\n        if (e.touches.length) return;\n    }\n\n    tapped = false;\n    if (!dragging) return;\n    timeStop = Date.now();\n    calculateVelocity();\n    dragging = false;\n    $('body').add(target).removeClass('jsn-es-draggable-dragging');\n    target.trigger(createEvent('es_dragstop', e), getData());\n    target.removeData('jsn-es-draggable-data');\n  }\n\n  function calculateVelocity() {\n    timeOffset = timeStop - timeStart;\n    velocityX = Math.abs(deltaX / timeOffset);\n    velocityY = Math.abs(deltaY / timeOffset);\n  }\n\n  function getData() {\n    var data = DRAG_DATA;\n    data.direction = direction;\n    data.axis = axis;\n    data.deltaX = deltaX;\n    data.deltaY = deltaY;\n    data.moveX = offsetX;\n    data.moveY = offsetY;\n    data.velocityX = velocityX;\n    data.velocityY = velocityY;\n    DRAG_DATA = data;\n    return data;\n  }\n\n  function bindEvent(element, event, handler, capture) {\n    if (element.addEventListener) return element.addEventListener(event, handler, capture);\n    if (element.attachEvent) return element.attachEvent(event, handler, capture);\n  }\n\n  function createEvent(type, e) {\n    var options = {};\n    options.originalEvent = e;\n    options.preventDefault = e.preventDefault.bind(e);\n    options.stopPropagation = e.stopPropagation.bind(e);\n    return $.Event(type, options);\n  }\n\n  function findParentNode(child) {\n    var parent = child.parentNode,\n        found = null;\n\n    while (parent && !found && !parent.isEqualNode(document.body)) {\n      parent.classList && parent.classList.contains('jsn-es-draggable') ? found = parent : parent = parent.parentNode;\n    }\n\n    return found;\n  }\n}(jQuery);\n\n//# sourceURL=webpack:///./draggable.js?");

/***/ }),

/***/ "./helpers.js":
/*!********************!*\
  !*** ./helpers.js ***!
  \********************/
/*! exports provided: SliderClasses, getSlideMovementData */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SliderClasses\", function() { return SliderClasses; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getSlideMovementData\", function() { return getSlideMovementData; });\nvar prefix = 'pf';\nvar SliderClasses = {\n  wrapper: \"\".concat(prefix, \"-slider-wrapper\"),\n  inner: \"\".concat(prefix, \"-slider-inner\"),\n  slide: \"\".concat(prefix, \"-slider-slide\"),\n  indicators: \"\".concat(prefix, \"-slider-pagination\"),\n  indicatorItem: \"\".concat(prefix, \"-slider-pagination-item\"),\n  controller: \"\".concat(prefix, \"-slider-nav\"),\n  disabledCtrl: \"\".concat(prefix, \"-slider-nav-disabled\"),\n  nextCtrl: \"\".concat(prefix, \"-next-nav\"),\n  prevCtrl: \"\".concat(prefix, \"-prev-nav\"),\n  turnOffMouseEvent: \"\".concat(prefix, \"-slider-mouse-event-off\")\n};\nvar getSlideMovementData = function getSlideMovementData(slider, direction, toIndex) {\n  var nextIndex, nextSlidePos, currSlidePos;\n\n  if (direction === \"next\") {\n    toIndex ? nextIndex = toIndex : nextIndex = slider.opts.curr === slider.totalSlide - 1 ? 0 : slider.opts.curr + 1;\n    nextSlidePos = 100;\n    currSlidePos = -100;\n  } else if (direction === \"prev\") {\n    // toIndex = 0 is a falsy value\n    toIndex || toIndex === 0 ? nextIndex = toIndex : nextIndex = slider.opts.curr === 0 ? slider.totalSlide - 1 : slider.opts.curr - 1;\n    nextSlidePos = -100;\n    currSlidePos = 100;\n  }\n\n  return {\n    nextIndex: nextIndex,\n    nextSlidePos: nextSlidePos,\n    currSlidePos: currSlidePos\n  };\n};\n\n//# sourceURL=webpack:///./helpers.js?");

/***/ }),

/***/ "./main.js":
/*!*****************!*\
  !*** ./main.js ***!
  \*****************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ \"./helpers.js\");\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n__webpack_require__(/*! ./draggable */ \"./draggable.js\");\n\nvar wrapper = _helpers__WEBPACK_IMPORTED_MODULE_0__[\"SliderClasses\"].wrapper,\n    inner = _helpers__WEBPACK_IMPORTED_MODULE_0__[\"SliderClasses\"].inner,\n    slide = _helpers__WEBPACK_IMPORTED_MODULE_0__[\"SliderClasses\"].slide,\n    indicators = _helpers__WEBPACK_IMPORTED_MODULE_0__[\"SliderClasses\"].indicators,\n    controller = _helpers__WEBPACK_IMPORTED_MODULE_0__[\"SliderClasses\"].controller,\n    nextCtrl = _helpers__WEBPACK_IMPORTED_MODULE_0__[\"SliderClasses\"].nextCtrl,\n    prevCtrl = _helpers__WEBPACK_IMPORTED_MODULE_0__[\"SliderClasses\"].prevCtrl,\n    disabledCtrl = _helpers__WEBPACK_IMPORTED_MODULE_0__[\"SliderClasses\"].disabledCtrl,\n    turnOffMouseEvent = _helpers__WEBPACK_IMPORTED_MODULE_0__[\"SliderClasses\"].turnOffMouseEvent;\n\nvar SliderController =\n/*#__PURE__*/\nfunction () {\n  function SliderController(ele, opts) {\n    _classCallCheck(this, SliderController);\n\n    this.el = ele;\n    this.originalStyles = {\n      wrapper: '',\n      inner: [] // Create an observer to observe any style's change of slider (this is for updating height)\n      // NOTE: this doesn't work on IE < 11 \n      // this.styleObserver = new MutationObserver(this.handleStyleChange.bind(this))\n      // this.styleObserver.observe(this.el, { attributes: true, attributeFilter: ['style', 'class'] })\n\n    };\n    this.$el = $(this.el); // The original element\n\n    this.$slider = ''; // The .inner div that wrap all slide\n\n    this.sliderHeight = this.$el.height();\n    this.sliderWidth = this.$el.width();\n    this.totalSlide = this.$el.children().length;\n    this.opts = $.extend({}, opts); // Each slider's opts is a specific instance of opts argument\n\n    this.autoPlayTimeoutId = ''; // Setup DOM + set event handler\n\n    this.initialize();\n    this.$el.on('click', this.handleClick.bind(this)); // Set up drag n drop event\n\n    this.moveByDrag = false;\n    this.$slider.on('es_dragmove', this.handleDragMove.bind(this));\n    this.$slider.on('es_dragstop', this.handleDragStop.bind(this));\n    console.log(this);\n  }\n\n  _createClass(SliderController, [{\n    key: \"initialize\",\n    value: function initialize() {\n      this.verifyOptions();\n      this.setupSliderDOM();\n      this.setAutoPlay();\n      return this;\n    }\n  }, {\n    key: \"setupSliderDOM\",\n    value: function setupSliderDOM() {\n      var _this = this;\n\n      this.$el.addClass(wrapper); // Save original styles\n\n      this.originalStyles.wrapper = this.$el.attr('style') ? this.$el.attr('style') : ''; // Create an inner div to wrap all slide item\n\n      var $inner = $(\"<div></div>\");\n      this.$el.children().each(function (i, child) {\n        // Save original styles\n        var childStyles = $(child).attr('style') ? $(child).attr('style') : '';\n\n        _this.originalStyles.inner.push(childStyles);\n\n        $inner.append(child);\n      }); // Save the inner DOM\n\n      this.$slider = $inner; // Append controllers\n\n      var $nextCtrl = $(\"<a data-action='next'></a>\");\n      var $prevCtrl = $(\"<a data-action='prev'></a>\"); // Append indicators\n\n      var $indicators = $('<ol>');\n\n      for (var i = 0; i < this.totalSlide; i++) {\n        var $indItem = $(\"<li data-goto-slide=\".concat(i, \" data-action='goto'></li>\"));\n        $indicators.append($indItem);\n      }\n\n      this.$el.append($inner).append($indicators).append($prevCtrl).append($nextCtrl); // Add style for slider\n\n      this.updateSliderStyle();\n      this.udpateActiveSlideStyle(); // Save slider height\n      // this.sliderHeight = this.\n    }\n    /* SETUP EVENT DELEGATION */\n\n  }, {\n    key: \"handleClick\",\n    value: function handleClick(e) {\n      var action = e.target.getAttribute('data-action');\n\n      switch (action) {\n        case 'next':\n          this.next();\n          break;\n\n        case 'prev':\n          this.prev();\n          break;\n\n        case 'goto':\n          // DOMStringMap convert dataset from hyphen style to upperCase (goto-slide => gotoSlide)\n          var index = parseInt(e.target.getAttribute('data-goto-slide')) || 0;\n          this.goto(index);\n          break;\n\n        default:\n          console.log('Slider clicked');\n      }\n    }\n  }, {\n    key: \"handleStyleChange\",\n    value: function handleStyleChange(mutations) {\n      var _this2 = this;\n\n      // Currently: We can only detect the inline style change, if you append a class that have a height property \n      // the slider height will not update\n      // We will update this bug asap\n      mutations.forEach(function (mut) {\n        var height = $(mut.target).height();\n\n        if (height !== _this2.opts.height) {\n          _this2.updateOptions({\n            height: height\n          });\n        }\n      });\n    }\n  }, {\n    key: \"handleDragMove\",\n    value: function handleDragMove(e, data) {\n      if (Math.abs(data.moveX) < SliderController.constructor.MIN_DRAG_DISTANCE) return;\n      this.clearAutoPlay();\n      var translateRange = data.moveX / this.sliderWidth * 100; // -30\n\n      var nextTranslateRange = 100 + translateRange; // => 70\n\n      var prevTranslateRange = -100 + translateRange; // => -130\n\n      var curr = this.opts.curr;\n      var $curr = this.$slider.children().eq(curr);\n\n      var _getSlideMovementData = Object(_helpers__WEBPACK_IMPORTED_MODULE_0__[\"getSlideMovementData\"])(this, 'next'),\n          nextIndex = _getSlideMovementData.nextIndex;\n\n      var $next = this.$slider.children().eq(nextIndex); // TODO: fix this dummy code\n      // This is stupid because the getMovementData return the variable name nextIndex\n\n      nextIndex = Object(_helpers__WEBPACK_IMPORTED_MODULE_0__[\"getSlideMovementData\"])(this, 'prev').nextIndex;\n      var prevIndex = nextIndex;\n      var $prev = this.$slider.children().eq(prevIndex); // Drag is forbidden in these below cases:\n\n      if (curr === 0 && !this.opts.loop && translateRange > 0) return;\n      if (curr === this.totalSlide - 1 && !this.opts.loop && translateRange < 0) return; // The key is: move all 3 slide! Genius!\n\n      this.translateSlide($prev, prevTranslateRange);\n      this.translateSlide($curr, translateRange);\n      this.translateSlide($next, nextTranslateRange);\n    }\n  }, {\n    key: \"handleDragStop\",\n    value: function handleDragStop(e, data) {\n      if (Math.abs(data.moveX) < SliderController.constructor.MIN_DRAG_DISTANCE) return; // Turn off draggable until slides move completely\n\n      this.moveByDrag = true;\n      var MIN_MOUSE_SPEED_TO_MOVE_SLIDE = 1;\n      var MIN_DISTANCE_RATIO_TO_MOVE_SLIDE = 0.3; // 30%\n\n      var mouseSpeed = data.velocityX;\n      var distRatio = data.moveX / this.sliderWidth;\n      var direction = '';\n      var duration; // TOTO: Make this block code shorter (Seem unneccessary ?)\n\n      if (mouseSpeed > MIN_MOUSE_SPEED_TO_MOVE_SLIDE || Math.abs(distRatio) > MIN_DISTANCE_RATIO_TO_MOVE_SLIDE) {\n        duration = this.opts.duration - Math.abs(distRatio) * this.opts.duration;\n        if (distRatio < 0) direction = 'next';else if (distRatio > 0) direction = 'prev';\n      } else {\n        duration = Math.abs(distRatio) * this.opts.duration;\n        /**\n         * This is a bit tricky\n         * In case we have to move the slides to the original position, I change the curr slide index to reuse the \n         * next() n prev() functions\n         */\n\n        if (distRatio < 0) {\n          this.opts.curr += 1;\n          direction = 'prev';\n        } else if (distRatio > 0) {\n          this.opts.curr -= 1;\n          direction = 'next';\n        }\n      } // Dummy: the moveSlide() need toIndex as the 2nd argument\n\n\n      var toIndex = undefined;\n      this.moveSlide(direction, toIndex, duration);\n    }\n    /* LOGIC FUNCTION */\n\n  }, {\n    key: \"verifyOptions\",\n    value: function verifyOptions() {\n      var defOpts = this.constructor.defaultOptions;\n\n      for (var key in defOpts) {\n        var value = defOpts[key];\n\n        if (_typeof(this.opts[key]) !== _typeof(value)) {\n          this.opts[key] = value;\n        }\n      } // Set the slider height\n\n\n      this.opts.height = this.sliderHeight || this.opts.height; // Turn off autoPlay if loop is false\n\n      if (!this.opts.loop) this.opts.autoPlay = false; // Set the style of slider nav n pagination to legal values\n\n      var defPags = this.constructor.styleOptions.paginations;\n      var defNavs = this.constructor.styleOptions.navs;\n      if (defPags.indexOf(this.opts.paginationStyle) < 0) this.opts.paginationStyle = defPags[0];\n      if (defNavs.indexOf(this.opts.navStyle) < 0) this.opts.navStyle = defNavs[0];\n    }\n  }, {\n    key: \"updateOptions\",\n    value: function updateOptions(newOtps) {\n      var defaultOptions = this.constructor.defaultOptions;\n      var defPags = this.constructor.styleOptions.paginations;\n      var currPag = this.opts.paginationStyle;\n      var defNavs = this.constructor.styleOptions.navs;\n      var currNav = this.opts.navStyle;\n\n      for (var key in newOtps) {\n        // The type of newOpts values must be legal\n        // And update 'curr' key is forbidden\n        if (_typeof(newOtps[key]) === _typeof(defaultOptions[key]) && key !== 'curr') {\n          var newValue = newOtps[key]; // Keep the current pagination n nav style if the new options is not valid\n\n          if (key === 'paginationStyle' && defPags.indexOf(newOtps[key]) < 0) newValue = currPag;\n          if (key === 'navStyle' && defNavs.indexOf(newOtps[key]) < 0) newValue = currNav;\n          this.opts[key] = newValue;\n        }\n      } // Turn off autoPlay if loop is false\n\n\n      if (!this.opts.loop) this.opts.autoPlay = false; // Set the style of slider nav n pagination to legal values\n\n      this.updateSliderStyle();\n      this.updateSliderCtrlStyle(this.opts.curr);\n      this.setAutoPlay();\n    }\n  }, {\n    key: \"setAutoPlay\",\n    value: function setAutoPlay() {\n      var _this3 = this;\n\n      if (this.opts.autoPlay) {\n        this.autoPlayTimeoutId = setTimeout(function () {\n          _this3.moveSlide('next');\n        }, this.opts.autoPlayDelay);\n      }\n    }\n  }, {\n    key: \"clearAutoPlay\",\n    value: function clearAutoPlay() {\n      clearTimeout(this.autoPlayTimeoutId);\n    }\n    /* CONTROLLER FUNCTIONS */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var _this4 = this;\n\n      this.clearAutoPlay(); // Save all items, remove all classes, inline-style n reverse the original style\n\n      var items = [];\n      this.$slider.children().each(function (i, child) {\n        $(child).removeClass(slide).removeClass('active').attr('style', '').attr('style', _this4.originalStyles.inner[i]);\n        items.push($(child));\n      }); // Remove class, event handler, data-instance and all children\n      // We currently don't change any style of the original element but I stll do .attr(...) for might-exist-problems in the future\n\n      this.$el.removeClass(wrapper).attr('style', '').attr('style', this.originalStyles.wrapper);\n      this.$el.off('click', this.handleClick);\n      this.$el.data('pf-slider-x', '');\n      this.$el.empty(); // Append the original item\n\n      for (var _i = 0; _i < items.length; _i++) {\n        var item = items[_i];\n        this.$el.append(item);\n      }\n    }\n  }, {\n    key: \"moveSlide\",\n    value: function moveSlide(direction, toIndex, customDuration) {\n      var _this5 = this;\n\n      this.clearAutoPlay(); // Move slide if forbidden in the 1st n last slide if Slider movement is not loop\n\n      var currIndex = this.opts.curr;\n      if (direction === 'prev' && currIndex === 0 && !this.opts.loop || direction === 'next' && currIndex === this.totalSlide - 1 && !this.opts.loop) return;\n      this.$el.addClass(turnOffMouseEvent);\n\n      var _getSlideMovementData2 = Object(_helpers__WEBPACK_IMPORTED_MODULE_0__[\"getSlideMovementData\"])(this, direction, toIndex),\n          nextIndex = _getSlideMovementData2.nextIndex,\n          nextSlidePos = _getSlideMovementData2.nextSlidePos,\n          currSlidePos = _getSlideMovementData2.currSlidePos;\n\n      var $curr = this.$slider.children().eq(currIndex);\n      var $next = this.$slider.children().eq(nextIndex);\n\n      if (this.opts.adaptiveHeight) {\n        var nextHeight = $next.height();\n        this.$slider.css({\n          height: \"\".concat(nextHeight, \"px\")\n        });\n      }\n\n      if (!this.moveByDrag) {\n        // Only move the $next slide to the ready-position in case user does not drag\n        this.translateSlide($next, nextSlidePos);\n      }\n\n      this.updateSliderCtrlStyle(nextIndex); // Move 2 slide contemporary\n\n      var duration = customDuration ? customDuration : this.opts.duration;\n      setTimeout(function () {\n        _this5.translateSlide($curr, currSlidePos, duration);\n\n        _this5.translateSlide($next, 0, duration); // Do stuffs after slides moving complete\n\n\n        setTimeout(function () {\n          _this5.setAutoPlay();\n\n          _this5.$el.removeClass(turnOffMouseEvent);\n\n          _this5.moveByDrag = false;\n        }, duration);\n      }, 50); // Update curr index n reset the .active\n\n      this.opts.curr = nextIndex;\n      this.udpateActiveSlideStyle();\n    }\n  }, {\n    key: \"translateSlide\",\n    value: function translateSlide($slide, toX, duration) {\n      if (duration) {\n        $slide.css({\n          'transition': \"transform \".concat(duration, \"ms linear\")\n        });\n      } else {\n        $slide.css({\n          'transition': ''\n        });\n      }\n\n      $slide.css('transform', \"translate3d(\".concat(toX, \"%, 0, 0)\"));\n    }\n  }, {\n    key: \"next\",\n    value: function next() {\n      this.moveSlide(\"next\");\n    }\n  }, {\n    key: \"prev\",\n    value: function prev() {\n      this.moveSlide(\"prev\");\n    }\n  }, {\n    key: \"goto\",\n    value: function goto(index) {\n      if (index > this.opts.curr) {\n        this.moveSlide(\"next\", index);\n      } else if (index < this.opts.curr) {\n        this.moveSlide(\"prev\", index);\n      }\n    }\n    /* STYLE FUNCTIONS */\n\n  }, {\n    key: \"updateSliderStyle\",\n    value: function updateSliderStyle() {\n      var $slides = this.$slider.children();\n      var $curr = $slides.eq(this.opts.curr);\n      var _this$opts = this.opts,\n          adaptiveHeight = _this$opts.adaptiveHeight,\n          height = _this$opts.height;\n\n      if (!adaptiveHeight) {\n        // Slider height = the highest child in case adaptiveHeight is off\n        // for (let i = 0; i < $slides.length; i++) {\n        //   if ($slides.eq(i).height() > sliderHeight) sliderHeight = $slides.eq(i).height()\n        // }\n        // Stretch all slide height to equal to the heightest slide\n        $slides.css({\n          'height': '100%'\n        });\n        this.$slider.css({\n          'height': '100%',\n          'transition': ''\n        });\n        this.$el.css({\n          'transition': ''\n        });\n      } else {\n        $slides.css({\n          'height': ''\n        });\n        this.$el.css('transition', \"height \".concat(this.opts.duration, \"ms ease-in-out\"));\n        this.$slider.css('transition', \"height \".concat(this.opts.duration, \"ms ease-in-out\"));\n        this.$el.css('height', '');\n        this.$slider.css('height', \"\".concat($curr.height(), \"px\"));\n      }\n\n      $slides.addClass(slide);\n      $curr.css('transform', 'translate3d(0, 0, 0)');\n      this.$slider.addClass(inner);\n      this.opts.draggable ? this.$slider.addClass('jsn-es-draggable') : this.$slider.removeClass('jsn-es-draggable');\n      var navStyle = this.opts.navStyle;\n      var paginationStyle = this.opts.paginationStyle;\n      this.$el.children('a[data-action=\"next\"]').attr('class', '').attr('class', \"\".concat(nextCtrl, \" \").concat(controller, \" \").concat(navStyle));\n      this.$el.children('a[data-action=\"prev\"]').attr('class', '').attr('class', \"\".concat(prevCtrl, \" \").concat(controller, \" \").concat(navStyle));\n      this.$el.children('ol').attr('class', '').attr('class', \"\".concat(indicators, \" \").concat(paginationStyle)); // Toggle show/hide nav/pagination\n\n      navStyle === 'none' ? this.$el.children('a').hide() : this.$el.children('a').show();\n      paginationStyle === 'none' ? this.$el.children('ol').hide() : this.$el.children('ol').show();\n    }\n  }, {\n    key: \"updateSliderCtrlStyle\",\n    value: function updateSliderCtrlStyle(index) {\n      this.$el.find('a').removeClass(disabledCtrl);\n\n      if (index === 0 && !this.opts.loop) {\n        this.$el.find(\".\".concat(prevCtrl)).addClass(disabledCtrl);\n      } else if (index === this.totalSlide - 1 && !this.opts.loop) {\n        this.$el.find(\".\".concat(nextCtrl)).addClass(disabledCtrl);\n      }\n    }\n  }, {\n    key: \"udpateActiveSlideStyle\",\n    value: function udpateActiveSlideStyle() {\n      // Add class .active for current active slide n indicator\n      var curr = this.opts.curr;\n      this.$slider.children(\".\".concat(slide, \".active\")).removeClass('active');\n      this.$slider.children().eq(curr).addClass('active');\n      this.$el.find('li.active').removeClass('active');\n      this.$el.find('ol').children().eq(curr).addClass('active');\n      this.updateSliderCtrlStyle(curr);\n    }\n  }]);\n\n  return SliderController;\n}(); // Class properties\n\n\nSliderController.constructor.MIN_DRAG_DISTANCE = 5;\nSliderController.defaultOptions = {\n  curr: 0,\n  autoPlay: true,\n  autoPlayDelay: 3000,\n  duration: 450,\n  loop: true,\n  draggable: true,\n  paginationStyle: 'pagination-style-1',\n  navStyle: 'nav-style-1',\n  adaptiveHeight: false,\n  height: 400\n};\nSliderController.styleOptions = {\n  /**\n   * The default style is the first array element\n   * Add more style (class name) for pagination or nav to these below arrays\n   * Remember to keep the 'none' in order to toggle show/hide pagination/nav option\n   */\n  paginations: ['pagination-style-1', 'pagination-style-2', 'pagination-style-3', 'none'],\n  navs: ['nav-style-1', 'nav-style-2', 'nav-style-3', 'nav-style-4', 'nav-style-5', 'none'] // Create jquery plugin\n\n};\n\n(function ($) {\n  $.fn.slider = function (opts) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    return this.each(function (i, element) {\n      var instance = $(element).data('pf-slider-x');\n\n      if (!instance) {\n        if (typeof opts === 'string') {\n          throw new Error('This element was not initialized as a Slider yet');\n        }\n\n        instance = new SliderController(element, opts);\n        $(element).data('pf-slider-x', instance);\n      } else {\n        if (typeof opts === 'string') {\n          var _instance;\n\n          (_instance = instance)[opts].apply(_instance, args);\n        }\n      }\n    });\n  };\n})(jQuery);\n\n//# sourceURL=webpack:///./main.js?");

/***/ })

/******/ });